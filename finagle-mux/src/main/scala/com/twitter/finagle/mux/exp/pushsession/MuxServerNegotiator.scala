package com.twitter.finagle.mux.exp.pushsession

import com.twitter.finagle.mux.{Handshake, Request, Response}
import com.twitter.finagle.mux.Handshake.{CanTinitMsg, Headers, TinitTag}
import com.twitter.finagle.{Mux, Service, Status}
import com.twitter.finagle.mux.transport.Message
import com.twitter.finagle.exp.pushsession.{PushChannelHandle, PushSession, RefPushSession}
import com.twitter.io.{Buf, ByteReader}
import com.twitter.logging.{Level, Logger}
import com.twitter.util._
import scala.util.control.NonFatal

/**
 * Session which negotiates Mux features
 *
 * Instances of the `MuxServerNegotiator` assume ownership of the provided `Service` and
 * `PushChannelHandle`. Upon successful completion of the negotiation process ownership
 * of these is transferred to the session generated by the `negotiate` function.
 *
 * Thread safety considerations
 * - `receive` is only intended to be called from within the serial executor associated with
 *   the provided `PushChannelHandle`.
 * - `negotiation` will be called from within the `serialExecutor`
 * - `close` and `status` are safe to call from any thread.
 */
private[finagle] class MuxServerNegotiator private(
  handle: PushChannelHandle[ByteReader, Buf],
  service: Service[Request, Response],
  makeLocalHeaders: Headers => Headers,
  negotiate: (Service[Request, Response], Option[Headers]) => PushSession[ByteReader, Buf],
  timer: Timer
) extends PushSession[ByteReader, Buf](handle) {
  import MuxServerNegotiator.log

  private[this] type Phase = Message => Unit

  private[this] val sessionP = Promise[PushSession[ByteReader, Buf]]
  private[this] var handshakePhase: Phase = checkRerrPhase
  
  @volatile
  private[this] var refSession: RefPushSession[ByteReader, Buf] = null

  // We need to be able to set the `refSession` after construction since
  // the `RefPushSession` needs a reference to `this` during its construction,
  // but `this` needs to be able to replace itself in the `RefPushSession`.
  private def setRefSession(ref: RefPushSession[ByteReader, Buf]): Unit = {
    refSession = ref
  }

  def onClose: Future[Unit] = handle.onClose

  handle.onClose.ensure {
    // If we have already completed negotiation, no need to close ourselves
    if (!sessionP.isDefined) close()
  }

  def close(deadline: Time): Future[Unit] = {
    // We want to proxy close calls to the underlying session, provided it resolves in time.
    // This facilitates draining behavior.
    sessionP.by(deadline)(timer).transform {
      case Return(session) => session.close(deadline)
      case Throw(_) => Closable.all(handle, service).close()
    }
  }

  def status: Status = handle.status

  def receive(message: ByteReader): Unit = {
    try {
      val msg = Message.decode(message)
      handshakePhase(msg)
    } catch {
      case NonFatal(t) =>
        close()
        throw t
    } finally message.close()
  }

  private[this] def checkRerrPhase: Phase = {
    case Message.Rerr(Handshake.TinitTag, Handshake.CanTinitMsg) =>
      if (log.isLoggable(Level.DEBUG)) {
        log.debug(s"Received Rerr prelude to Tinit. $remoteAddressString")
      }
      // Prepare to receive the Tinit and send the Rerr reply
      handshakePhase = getInitPhase
      handle.sendAndForget(Message.encode(Message.Rerr(TinitTag, CanTinitMsg)))

    case message => // No negotiation: just init a basic session
      if (log.isLoggable(Level.DEBUG)) {
        log.debug(s"Rerr prelude not detected (received ${message.getClass.getSimpleName}. " +
          s"Skipping Init phase. $remoteAddressString")
      }
      noInit(message)
  }

  private[this] def getInitPhase: Phase = {
    case Message.Tinit(tag, Mux.LatestVersion, headers) =>
      try {
        val localHeaders = makeLocalHeaders(headers)
        // pipeline changes for Opp-TLS
        handle.sendAndForget(Message.encode(Message.Rinit(tag, Mux.LatestVersion, localHeaders)))
        val session = negotiate(service, Some(headers))
        negotiationSuccess(session)
      } catch {
        case NonFatal(t) => negotiationFailure(tag, t)
      }

    case Message.Tinit(tag, v, _) =>
      val ex = new IllegalStateException(s"Unsupported Mux version: $v")
      negotiationFailure(tag, ex)

    case message =>
      log.warning("Received Rerr init probe but didn't receive a follow up " +
        s"Tinit (received a ${message.getClass.getSimpleName}). $remoteAddressString")
      noInit(message)
  }

  // helper for logging purposes
  private[this] def remoteAddressString: String = s"remote: ${handle.remoteAddress}"

  private[this] def noInit(message: Message): Unit = {
    try {
      val session = negotiate(service, None)
      // Register the new session and then give it the message
      negotiationSuccess(session)
      session.receive(ByteReader(Message.encode(message)))
    } catch {
      case NonFatal(t) => negotiationFailure(message.tag, t)
    }
  }

  private[this] def negotiationSuccess(session: PushSession[ByteReader, Buf]): Unit = {
    // Upon success, we need to
    // 1. redirect events to the new session
    // 2. satisfy the promise which will trigger any pending `close` calls that occurred
    //    before negotiation completed.
    // The order of these events is not strictly important but its generally a good idea to
    // reshape our pipeline before triggering potentially arbitrary events via satisfying a
    // promise.
    refSession.updateRef(session)
    sessionP.setValue(session)
    handshakePhase = { m: Message =>
      // Should never get here
      val msg = "After negotiation success, more messages were sent to the " +
        s"negotiating session: ${m.getClass.getSimpleName}. $remoteAddressString"
      val ex = new IllegalStateException(msg)
      log.error(ex, msg)
      handle.close()
    }
  }

  private[this] def negotiationFailure(tag: Int, t: Throwable): Unit = {
    // Negotiation failed, so we need to cleanup and shutdown.
    log.warning(t, s"Negotiation failed. Closing session. $remoteAddressString")

    // This is not necessarily unexpected if the peer thinks the session is now open
    handshakePhase = { msg: Message =>
      if (log.isLoggable(Level.DEBUG)) {
        log.debug(t, s"Session negotiation failed. Swallowing message " +
          s"(${msg.getClass.getSimpleName}) that raced shutdown. $remoteAddressString")
      }
    }

    handle.send(Message.encode((Message.Rerr(tag, t.getMessage)))) { _ =>
      close().ensure {
        sessionP.setException(t)
      }
    }
  }
}

private object MuxServerNegotiator {
  private val log = Logger.get

  def apply(
    handle: PushChannelHandle[ByteReader, Buf],
    service: Service[Request, Response],
    makeLocalHeaders: Headers => Headers,
    negotiate: (Service[Request, Response], Option[Headers]) => PushSession[ByteReader, Buf],
    timer: Timer
  ): PushSession[ByteReader, Buf] = {
    val negotiatingSession = new MuxServerNegotiator(handle, service, makeLocalHeaders, negotiate, timer)
    val ref = new RefPushSession[ByteReader, Buf](handle, negotiatingSession)
    negotiatingSession.setRefSession(ref)
    ref
  }
}
