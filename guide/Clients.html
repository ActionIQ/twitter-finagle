<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Clients &#8212; Finagle 18.7.0 documentation</title>
    
    <link rel="stylesheet" href="_static/finagle.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '18.7.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="top" title="Finagle 18.7.0 documentation" href="index.html" />
    <link rel="next" title="Contexts" href="Contexts.html" />
    <link rel="prev" title="Servers" href="Servers.html" />
   
  
  <link media="only screen and (max-device-width: 480px)" href="_static/small_flask.css" type= "text/css" rel="stylesheet" />
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-39101739-4', 'twitter.github.io');
    ga('send', 'pageview');

  </script>

  </head>
  <body role="document">
  
  

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="Contexts.html" title="Contexts"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="Servers.html" title="Servers"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Finagle</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="clients">
<span id="finagle-clients"></span><h1>Clients<a class="headerlink" href="#clients" title="Permalink to this headline">¶</a></h1>
<p>Finagle clients adheres to a simple <a class="reference external" href="https://github.com/twitter/finagle/blob/master/finagle-core/src/main/scala/com/twitter/finagle/Client.scala">interface</a> for
construction:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">newClient</span><span class="o">(</span><span class="n">dest</span><span class="k">:</span> <span class="kt">Name</span><span class="o">,</span> <span class="n">label</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">ServiceFactory</span><span class="o">[</span><span class="kt">Req</span>, <span class="kt">Rep</span><span class="o">]</span>
</pre></div>
</div>
<p>That is, given a logical destination and an identifier, return a function
that produces a typed <cite>Service</cite> over which requests can be dispatched.
There are variants of this constructor for stateless clients that create a simple
<cite>Service</cite>, for example:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">newService</span><span class="o">(</span><span class="n">dest</span><span class="k">:</span> <span class="kt">Name</span><span class="o">,</span> <span class="n">label</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Service</span><span class="o">[</span><span class="kt">Req</span>, <span class="kt">Rep</span><span class="o">]</span>
</pre></div>
</div>
<p>As of <a class="reference internal" href="changelog.html"><span class="doc">6.x</span></a>, client implementations are encouraged to expose
this interface on a Scala object named after the protocol implementation. This
results in a uniform way to construct clients, <code class="docutils literal"><span class="pre">Protocol.newClient(...)</span></code> or
<code class="docutils literal"><span class="pre">Protocol.newService(...)</span></code>. For example:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">com.twitter.finagle.Service</span>
<span class="k">import</span> <span class="nn">com.twitter.finagle.Http</span>
<span class="k">import</span> <span class="nn">com.twitter.finagle.http.</span><span class="o">{</span><span class="nc">Request</span><span class="o">,</span> <span class="nc">Response</span><span class="o">}</span>

<span class="k">val</span> <span class="n">twitter</span><span class="k">:</span> <span class="kt">Service</span><span class="o">[</span><span class="kt">Request</span>, <span class="kt">Response</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Http</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">newService</span><span class="o">(</span><span class="s">&quot;twitter.com&quot;</span><span class="o">)</span>
</pre></div>
</div>
<p>Clients can further furnish the resulting <cite>ServiceFactory</cite> with protocol
specific API&#8217;s. A common pattern is to expose a <code class="docutils literal"><span class="pre">newRichClient</span></code> method that
does exactly this. For cases like Thrift, where IDLs are part of
the rich API, a more specialized API is exposed. See the protocols section on
<a class="reference internal" href="Protocols.html#thrift-and-scrooge"><span class="std std-ref">Thrift</span></a> for more details.</p>
<div class="section" id="transport">
<h2>Transport<a class="headerlink" href="#transport" title="Permalink to this headline">¶</a></h2>
<p>Finagle clients come with a variety of transport-level parameters that not only wire up TCP socket
options, but also upgrade the transport protocol to support encryption (e.g. TLS/SSL) and proxy
servers (e.g. HTTP, SOCKS5).</p>
<div class="section" id="http-proxy">
<h3>HTTP Proxy<a class="headerlink" href="#http-proxy" title="Permalink to this headline">¶</a></h3>
<p>There is built-in support for <a class="reference external" href="https://tools.ietf.org/html/draft-luotonen-web-proxy-tunneling-01">tunneling TCP-based protocols</a>
through web proxy servers in a default Finagle client that might be used with any TCP traffic, not
only HTTP(S). See <a class="reference external" href="http://wiki.squid-cache.org/Features/HTTPS">Squid documentation</a> on this feature.</p>
<p>The following example enables tunneling HTTP traffic through a web proxy server <cite>my-proxy-server.com</cite>
to <cite>twitter.com</cite>.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">com.twitter.finagle.</span><span class="o">{</span><span class="nc">Service</span><span class="o">,</span> <span class="nc">Http</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">com.twitter.finagle.http.</span><span class="o">{</span><span class="nc">Request</span><span class="o">,</span> <span class="nc">Response</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">com.twitter.finagle.client.Transporter</span>
<span class="k">import</span> <span class="nn">java.net.SocketAddress</span>

<span class="k">val</span> <span class="n">twitter</span><span class="k">:</span> <span class="kt">Service</span><span class="o">[</span><span class="kt">Request</span>, <span class="kt">Response</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Http</span><span class="o">.</span><span class="n">client</span>
  <span class="o">.</span><span class="n">withTransport</span><span class="o">.</span><span class="n">httpProxyTo</span><span class="o">(</span>
    <span class="n">host</span> <span class="k">=</span> <span class="s">&quot;twitter.com:443&quot;</span><span class="o">,</span>
    <span class="n">credentials</span> <span class="k">=</span> <span class="nc">Transporter</span><span class="o">.</span><span class="nc">Credentials</span><span class="o">(</span><span class="s">&quot;user&quot;</span><span class="o">,</span> <span class="s">&quot;password&quot;</span><span class="o">)</span>
  <span class="o">)</span>
  <span class="o">.</span><span class="n">newService</span><span class="o">(</span><span class="s">&quot;inet!my-proxy-server.com:3128&quot;</span><span class="o">)</span> <span class="c1">// using local DNS to resolve proxy</span>
</pre></div>
</div>
<p>While this setup may look somewhat counter intuitive with regards to where the ultimate destination
and the proxy server address are applied, it enables a variety of resiliency features by utilizing
Finagle&#8217;s naming and load balancing subsystems. Given a web proxy server address/name falls under
a standard name resolution process, it might be (and should be) backed by a replica set (multiple
hosts) to get the greatest out of a client.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">There is also a legacy support to web proxy servers available in Finagle via the
<cite>Transporter.HttpProxy</cite> stack param. In that case, proxy server is forced to represented as a single
<cite>SocketAddress</cite>, which not only introduces a single point of failure within a client (i.e., a
client goes offline if a web proxy server is down), but also disables Finagle&#8217;s resiliency features
such as failure detection and load balancing.</p>
</div>
</div>
<div class="section" id="socks5-proxy">
<h3>SOCKS5 Proxy<a class="headerlink" href="#socks5-proxy" title="Permalink to this headline">¶</a></h3>
<p>SOCKS5 proxy support in Finagle is designed and implemented exclusively for testing/development
(assuming that SOCKS proxy is provided via <cite>ssh -D</cite>), not for production usage. For production
traffic, an HTTP(S) proxy should be used instead.</p>
<p>Use the following CLI flags to enable SOCKS proxy on every Finagle client on a given JVM instance
(username and password are optional).</p>
<div class="highlight-shell"><div class="highlight"><pre><span></span>-com.twitter.finagle.socks.socksProxyHost<span class="o">=</span>localhost <span class="se">\</span>
-com.twitter.finagle.socks.socksProxyPort<span class="o">=</span><span class="m">50001</span> <span class="se">\</span>
-com.twitter.finagle.socks.socksUsername<span class="o">=</span><span class="nv">$TheUsername</span> <span class="se">\</span>
-com.twitter.finagle.socks.socksPassword<span class="o">=</span><span class="nv">$ThePassword</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="client-modules">
<span id="id1"></span><h2>Client Modules<a class="headerlink" href="#client-modules" title="Permalink to this headline">¶</a></h2>
<p>A default Finagle client is designed to maximize success and minimize latency.
Each request dispatched through a client will flow through various modules that
help it achieve these goals. The modules are logically separated into three
stacks: the <cite>client stack</cite> manages <cite>name</cite> resolution and balances requests
across multiple endpoints, the <cite>endpoint stack</cite> provides circuit breakers
and connection pooling, and the <cite>connection stack</cite> provides connection life-cycle
management and implements the wire protocol.</p>
<div class="figure" id="id32">
<img alt="_images/clientstack.svg" src="_images/clientstack.svg" /><p class="caption"><span class="caption-text">Fig. 1: A visual representation of each module in a default Finagle client
that is configured with three endpoints and connections. Requests flow from
left to right.</span></p>
</div>
<div class="section" id="module-composition">
<h3>Module Composition<a class="headerlink" href="#module-composition" title="Permalink to this headline">¶</a></h3>
<p>A materialized Finagle client is a <a class="reference internal" href="ServicesAndFilters.html#service-factory"><span class="std std-ref">ServiceFactory</span></a>. It produces
<a class="reference internal" href="ServicesAndFilters.html#services"><span class="std std-ref">Services</span></a> over which requests can be dispatched. The modules in
<cite>Fig. 1</cite> are defined in terms of a <cite>ServiceFactory</cite> and thus are composed via the usual
<a class="reference internal" href="ServicesAndFilters.html#composing-services-filters"><span class="std std-ref">combinators</span></a>. An important consequence of this is that
modules deeper in the stack can affect the behavior and availability of the client. For example,
this is how failure management modules mark entire endpoints as unavailable.</p>
</div>
<div class="section" id="observability">
<h3>Observability<a class="headerlink" href="#observability" title="Permalink to this headline">¶</a></h3>
<p>The <cite>Observe</cite>, <cite>Monitor</cite>, and <cite>Trace</cite> modules export useful information about the internals and
behavior of a Finagle client. Client metrics are exported using a
<a class="reference external" href="https://github.com/twitter/util/blob/master/util-stats/src/main/scala/com/twitter/finagle/stats/StatsReceiver.scala">StatsReceiver</a>
(see the <a class="reference internal" href="Metrics.html#public-stats"><span class="std std-ref">metrics</span></a> section for more details about specific metric values).</p>
<p>Unhandled exceptions can be handled by installing a custom
<a class="reference external" href="https://github.com/twitter/finagle/blob/master/finagle-core/src/main/scala/com/twitter/finagle/filter/MonitorFilter.scala">MonitorFilter</a> or overriding the default monitor
instance. The default setting for <code class="docutils literal"><span class="pre">MonitorFilter</span></code> is to log all the unhandled exception onto standard
output. To override this, use the following sample.</p>
<div class="highlight-scala" id="configuring-monitors"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">com.twitter.finagle.Service</span>
<span class="k">import</span> <span class="nn">com.twitter.finagle.Http</span>
<span class="k">import</span> <span class="nn">com.twitter.finagle.http.</span><span class="o">{</span><span class="nc">Request</span><span class="o">,</span> <span class="nc">Response</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">com.twitter.util.Monitor</span>

<span class="k">val</span> <span class="n">monitor</span><span class="k">:</span> <span class="kt">Monitor</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Monitor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">handle</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">Throwable</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
    <span class="c1">// do something with the exception</span>
    <span class="kc">true</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">twitter</span><span class="k">:</span> <span class="kt">Service</span><span class="o">[</span><span class="kt">Request</span>, <span class="kt">Response</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Http</span><span class="o">.</span><span class="n">client</span>
  <span class="o">.</span><span class="n">withMonitor</span><span class="o">(</span><span class="n">monitor</span><span class="o">)</span>
  <span class="o">.</span><span class="n">newService</span><span class="o">(</span><span class="s">&quot;twitter.com&quot;</span><span class="o">)</span>
</pre></div>
</div>
<p>Finally, clients have built-in support for <a class="reference external" href="http://zipkin.io/">Zipkin</a>.</p>
</div>
<div class="section" id="retries">
<span id="client-retries"></span><h3>Retries<a class="headerlink" href="#retries" title="Permalink to this headline">¶</a></h3>
<p>Every Finagle client contains a <cite>Retries</cite> module in the stack, above load balancers,
so that it can retry failures from the underlying modules: circuit breakers, timeouts,
load balancers and connection pools. Retries can help improve the client&#8217;s logical success
rate when subsequent attempts succeed.</p>
<p>For the most part, service owners will be interested in the logical success rate of a clients.
Logical requests represent the result of the initial request, after any retries have occurred.
Concretely, should a request result in a retryable failure on the first attempt, but succeed upon
retry, this is considered a single successful logical request. By default, a Finagle client&#8217;s
success rate metrics include the individual attempts and this can cause confusion.
<a class="reference internal" href="MethodBuilder.html#methodbuilder"><span class="std std-ref">MethodBuilder</span></a> offers logical metrics scoped to &#8220;logical&#8221; for both
success rate and latency. The deprecated <code class="docutils literal"><span class="pre">ClientBuilder</span></code> code also offers similar metrics
scoped to &#8220;tries&#8221;.</p>
<p>Failures that are known to be safe to retry (for example, exceptions that occurred before the
bytes were written to the wire and protocol level NACKs) will be automatically retried by Finagle.
These retries come out of a <code class="docutils literal"><span class="pre">RetryBudget</span></code> that allows for approximately 20% of the total requests
to be retried on top of 10 retries per second in order to accommodate clients that have just started
issuing requests or clients that have a low rate of requests per second.</p>
<p>Some failures may also be known as unsafe to retry. If a <a class="reference external" href="https://github.com/twitter/finagle/blob/master/finagle-core/src/main/scala/com/twitter/finagle/Failure.scala">Failure</a>
is flagged <code class="docutils literal"><span class="pre">NonRetryable</span></code>, the <cite>Retries</cite> module will not make any attempts to retry the request and
pass along the failure as is. A <cite>NonRetryable</cite> failure may be used in situations where a client
determines that a service is unhealthy and wishes to signal that the normal pattern of retries should
be skipped. Additionally, a service may reject a request that is malformed and thus pointless to retry.
While Finagle respects the <cite>NonRetryable</cite> flag internally, users should also take care to respect it
when creating retry filters of their own.</p>
<p>The <cite>Retries</cite> module is configured with two parameters:</p>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">RetryBudget</span></code> - determines whether there is available budget to retry a request</li>
<li><code class="docutils literal"><span class="pre">Stream[Duration]</span></code> - the backoff <a class="footnote-reference" href="#backoff" id="id2">[1]</a> policy used to requeue the failed request</li>
</ol>
<p>By default, the <code class="docutils literal"><span class="pre">RetryBudget</span></code> allows for about 20% of the total requests to be immediately (no backoff)
retried on top of 10 retries per second in order to accommodate clients that have just started issuing
requests or clients that have a low rate of requests per second.</p>
<p>To override this default use the following code snippet.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">com.twitter.conversions.time._</span>
<span class="k">import</span> <span class="nn">com.twitter.finagle.Http</span>
<span class="k">import</span> <span class="nn">com.twitter.finagle.service.</span><span class="o">{</span><span class="nc">Backoff</span><span class="o">,</span> <span class="nc">RetryBudget</span><span class="o">}</span>

<span class="k">val</span> <span class="n">budget</span><span class="k">:</span> <span class="kt">RetryBudget</span> <span class="o">=</span> <span class="o">???</span>

<span class="k">val</span> <span class="n">twitter</span> <span class="k">=</span> <span class="nc">Http</span><span class="o">.</span><span class="n">client</span>
  <span class="o">.</span><span class="n">withRetryBudget</span><span class="o">(</span><span class="n">budget</span><span class="o">)</span>
  <span class="o">.</span><span class="n">withRetryBackoff</span><span class="o">(</span><span class="nc">Backoff</span><span class="o">.</span><span class="n">const</span><span class="o">(</span><span class="mf">10.</span><span class="n">seconds</span><span class="o">))</span>
  <span class="o">.</span><span class="n">newService</span><span class="o">(</span><span class="s">&quot;twitter.com&quot;</span><span class="o">)</span>
</pre></div>
</div>
<p>The following example <a class="footnote-reference" href="#example" id="id3">[3]</a> shows how to use a factory method <code class="docutils literal"><span class="pre">RetryBudget.apply</span></code> in order to
construct a new instance of <code class="docutils literal"><span class="pre">RetryBudget</span></code> backed by <em>leaky token bucket</em>.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">com.twitter.conversions.time._</span>
<span class="k">import</span> <span class="nn">com.twitter.finagle.service.RetryBudget</span>

<span class="k">val</span> <span class="n">budget</span><span class="k">:</span> <span class="kt">RetryBudget</span> <span class="o">=</span> <span class="nc">RetryBudget</span><span class="o">(</span>
  <span class="n">ttl</span> <span class="k">=</span> <span class="mf">10.</span><span class="n">seconds</span><span class="o">,</span>
  <span class="n">minRetriesPerSec</span> <span class="k">=</span> <span class="mi">5</span><span class="o">,</span>
  <span class="n">percentCanRetry</span> <span class="k">=</span> <span class="mf">0.1</span>
<span class="o">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">RetryBudget</span></code> factory method takes three arguments:</p>
<ol class="arabic simple">
<li><cite>ttl</cite> - a time to live for deposited tokens</li>
<li><cite>minRetriesPerSec</cite> - the minimum rate of retries allowed</li>
<li><cite>percentCanRetry</cite> - the percentage of requests that might be retried</li>
</ol>
<p>While the <a class="reference external" href="https://github.com/twitter/finagle/blob/master/finagle-core/src/main/scala/com/twitter/finagle/service/RequeueFilter.scala">RequeueFilter</a> (configured via <code class="docutils literal"><span class="pre">Retries</span></code>)
is inserted into every client&#8217;s stack by default so all the failures from the underlying modules will be
retried, the <a class="reference external" href="https://github.com/twitter/finagle/blob/master/finagle-core/src/main/scala/com/twitter/finagle/service/RetryFilter.scala">RetryFilter</a> handling application level
exceptions from the remote server should be applied explicitly.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">com.twitter.conversions.time._</span>
<span class="k">import</span> <span class="nn">com.twitter.finagle.Http</span>
<span class="k">import</span> <span class="nn">com.twitter.finagle.util.DefaultTimer</span>
<span class="k">import</span> <span class="nn">com.twitter.finagle.service.</span><span class="o">{</span><span class="nc">RetryBudget</span><span class="o">,</span> <span class="nc">RetryFilter</span><span class="o">,</span> <span class="nc">RetryPolicy</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">com.twitter.finagle.stats.NullStatsReceiver</span>
<span class="k">import</span> <span class="nn">com.twitter.util.Try</span>

<span class="k">val</span> <span class="n">twitter</span> <span class="k">=</span> <span class="nc">Http</span><span class="o">.</span><span class="n">client</span><span class="o">.</span><span class="n">newService</span><span class="o">(</span><span class="s">&quot;twitter.com&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">budget</span><span class="k">:</span> <span class="kt">RetryBudget</span> <span class="o">=</span> <span class="nc">RetryBudget</span><span class="o">()</span>
<span class="k">val</span> <span class="n">policy</span><span class="k">:</span> <span class="kt">RetryPolicy</span><span class="o">[</span><span class="kt">Try</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]]</span> <span class="k">=</span> <span class="o">???</span>

<span class="k">val</span> <span class="n">retry</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">RetryFilter</span><span class="o">(</span>
  <span class="n">retryPolicy</span> <span class="k">=</span> <span class="n">policy</span><span class="o">,</span>
  <span class="n">timer</span> <span class="k">=</span> <span class="nc">DefaultTimer</span><span class="o">,</span>
  <span class="n">statsReceiver</span> <span class="k">=</span> <span class="nc">NullStatsReceiver</span><span class="o">,</span>
  <span class="n">retryBudget</span> <span class="k">=</span> <span class="n">budget</span>
<span class="o">)</span>

<span class="k">val</span> <span class="n">retryTwitter</span> <span class="k">=</span> <span class="n">retry</span><span class="o">.</span><span class="n">andThen</span><span class="o">(</span><span class="n">twitter</span><span class="o">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">RetryPolicy</span></code> instance might be constructed in several ways:</p>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">RetryPolicy.tries</span></code> - retries using jittered backoff <a class="footnote-reference" href="#backoff" id="id4">[1]</a> between the given number
of maximum attempts</li>
<li><code class="docutils literal"><span class="pre">RetryPolicy.backoff</span></code> - retries using the given backoff <a class="footnote-reference" href="#backoff" id="id5">[1]</a> policy</li>
</ol>
<p>The following example <a class="footnote-reference" href="#example" id="id6">[3]</a> constructs an instance of <code class="docutils literal"><span class="pre">RetryPolicy</span></code> using the given backoff value.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">com.twitter.finagle.http.</span><span class="o">{</span><span class="nc">Response</span><span class="o">,</span> <span class="nc">Status</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">com.twitter.finagle.service.</span><span class="o">{</span><span class="nc">Backoff</span><span class="o">,</span> <span class="nc">RetryPolicy</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">com.twitter.util.</span><span class="o">{</span><span class="nc">Try</span><span class="o">,</span> <span class="nc">Return</span><span class="o">,</span> <span class="nc">Throw</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">com.twitter.conversions.time._</span>

<span class="k">val</span> <span class="n">policy</span><span class="k">:</span> <span class="kt">RetryPolicy</span><span class="o">[</span><span class="kt">Try</span><span class="o">[</span><span class="kt">Response</span><span class="o">]]</span> <span class="k">=</span>
  <span class="nc">RetryPolicy</span><span class="o">.</span><span class="n">backoff</span><span class="o">(</span><span class="nc">Backoff</span><span class="o">.</span><span class="n">equalJittered</span><span class="o">(</span><span class="mf">10.</span><span class="n">milliseconds</span><span class="o">,</span> <span class="mf">10.</span><span class="n">seconds</span><span class="o">))</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Return</span><span class="o">(</span><span class="n">rep</span><span class="o">)</span> <span class="k">if</span> <span class="n">rep</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="nc">Status</span><span class="o">.</span><span class="nc">InternalServerError</span> <span class="k">=&gt;</span> <span class="kc">true</span>
  <span class="o">}</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="Metrics.html#id1"><span class="std std-ref">Retries metrics</span></a> for more details.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It&#8217;s highly recommended to <cite>share</cite> a single instance of <code class="docutils literal"><span class="pre">RetryBudget</span></code> between both
<code class="docutils literal"><span class="pre">RetryFilter</span></code> and <code class="docutils literal"><span class="pre">RequeueFilter</span></code> to prevent <cite>retry storms</cite>.</p>
</div>
</div>
<div class="section" id="timeouts-expiration">
<h3>Timeouts &amp; Expiration<a class="headerlink" href="#timeouts-expiration" title="Permalink to this headline">¶</a></h3>
<p>Finagle provides timeout facilities with fine granularity:</p>
<p>The <cite>Session Timeout</cite> module defines a timeout for session acquisition. That is, it defines
the maximum time allotted to a request to wait for an available service/session. Requests
that exceed this timeout are failed with a <code class="docutils literal"><span class="pre">ServiceTimeoutException</span></code>. This module is
implemented by the <a class="reference external" href="https://github.com/twitter/finagle/blob/master/finagle-core/src/main/scala/com/twitter/finagle/factory/TimeoutFactory.scala">TimeoutFactory</a></p>
<p>The default timeout value for the <cite>Session Timeout</cite> module is unbounded (i.e., <code class="docutils literal"><span class="pre">Duration.Top</span></code>),
which simply means it&#8217;s disabled. Although, it&#8217;s possible to override the default setting with
stack params <a class="footnote-reference" href="#example" id="id7">[3]</a>.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">com.twitter.conversions.time._</span>
<span class="k">import</span> <span class="nn">com.twitter.finagle.Http</span>

<span class="k">val</span> <span class="n">twitter</span> <span class="k">=</span> <span class="nc">Http</span><span class="o">.</span><span class="n">client</span>
  <span class="o">.</span><span class="n">withSession</span><span class="o">.</span><span class="n">acquisitionTimeout</span><span class="o">(</span><span class="mf">42.</span><span class="n">seconds</span><span class="o">)</span>
  <span class="o">.</span><span class="n">newService</span><span class="o">(</span><span class="s">&quot;twitter.com&quot;</span><span class="o">)</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="Metrics.html#service-factory-failures"><span class="std std-ref">Service Latency metrics</span></a> for more details.</p>
<p>The <cite>Request Timeout</cite> module is a filter and thus gives an upper bound on the amount of
time allowed for a request to be outstanding. An important implementation detail of the
<a class="reference external" href="https://github.com/twitter/finagle/blob/master/finagle-core/src/main/scala/com/twitter/finagle/service/TimeoutFilter.scala">TimeoutFilter</a> is that it attempts
to cancel the request when a timeout is triggered. With most protocols, if the request has
already been dispatched, the only way to cancel the request is to terminate the connection.
Note that HTTP/2 and Mux both have first-class support for request cancellation without
needing to tear down the connection.</p>
<p>The default timeout for the <cite>Request Timeout</cite> module is unbounded (i.e., <code class="docutils literal"><span class="pre">Duration.Top</span></code>).
Here is an example <a class="footnote-reference" href="#example" id="id8">[3]</a> of how to override that default.</p>
<div class="highlight-scala" id="configuring-timeouts"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">com.twitter.conversions.time._</span>
<span class="k">import</span> <span class="nn">com.twitter.finagle.Http</span>

<span class="k">val</span> <span class="n">twitter</span> <span class="k">=</span> <span class="nc">Http</span><span class="o">.</span><span class="n">client</span>
  <span class="o">.</span><span class="n">withRequestTimeout</span><span class="o">(</span><span class="mf">42.</span><span class="n">seconds</span><span class="o">)</span>
  <span class="o">.</span><span class="n">newService</span><span class="o">(</span><span class="s">&quot;twitter.com&quot;</span><span class="o">)</span>
</pre></div>
</div>
<p>Regarding <a class="reference internal" href="#client-retries"><span class="std std-ref">retries</span></a>, the timeout is given to each attempt.</p>
<p>As Finagle does not know whether or not a request is idempotent, request timeouts
are not retried by default. However this can be configured through a
<a class="reference internal" href="#client-retries"><span class="std std-ref">retry policy</span></a>.</p>
<p>See <a class="reference internal" href="Metrics.html#metrics-stats-filter"><span class="std std-ref">Request Latency metrics</span></a> for more details.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This module only works with request/response usage and does not
support streaming (such as with HTTP).</p>
</div>
<p>The <cite>Expiration</cite> module is attached at the connection level and expires a service/session
after a certain amount of idle time. The module is implemented by
<a class="reference external" href="https://github.com/twitter/finagle/blob/master/finagle-core/src/main/scala/com/twitter/finagle/service/ExpiringService.scala">ExpiringService</a>.</p>
<p>The default setting for the <cite>Expiration</cite> module is to never expire a session. Here is how
it can be configured <a class="footnote-reference" href="#example" id="id9">[3]</a>.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">com.twitter.conversions.time._</span>
<span class="k">import</span> <span class="nn">com.twitter.finagle.Http</span>

<span class="k">val</span> <span class="n">twitter</span> <span class="k">=</span> <span class="nc">Http</span><span class="o">.</span><span class="n">client</span>
  <span class="o">.</span><span class="n">withSession</span><span class="o">.</span><span class="n">maxLifeTime</span><span class="o">(</span><span class="mf">20.</span><span class="n">seconds</span><span class="o">)</span>
  <span class="o">.</span><span class="n">withSession</span><span class="o">.</span><span class="n">maxIdleTime</span><span class="o">(</span><span class="mf">10.</span><span class="n">seconds</span><span class="o">)</span>
  <span class="o">.</span><span class="n">newService</span><span class="o">(</span><span class="s">&quot;twitter.com&quot;</span><span class="o">)</span>
</pre></div>
</div>
<p>The <cite>Expiration</cite> module takes two parameters:</p>
<ol class="arabic simple">
<li><cite>maxLifeTime</cite> - the maximum duration for which a session is considered alive</li>
<li><cite>maxIdleTime</cite> - the maximum duration for which a session is allowed to idle
(not sending any requests)</li>
</ol>
<p>See <a class="reference internal" href="Metrics.html#idle-apoptosis-stats"><span class="std std-ref">Expiration metrics</span></a> for more details.</p>
<p>Finally, timeouts can be enforced outside of these modules on a per-request level using
<code class="docutils literal"><span class="pre">Future#within</span></code> or <code class="docutils literal"><span class="pre">Future#raiseWithin</span></code>.  <a class="footnote-reference" href="#raise" id="id10">[4]</a>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">com.twitter.conversions.time._</span>
<span class="k">import</span> <span class="nn">com.twitter.finagle.http.</span><span class="o">{</span><span class="nc">Request</span><span class="o">,</span> <span class="nc">Response</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">com.twitter.util.Future</span>

<span class="k">val</span> <span class="n">response</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">Response</span><span class="o">]</span> <span class="k">=</span> <span class="n">twitter</span><span class="o">(</span><span class="n">request</span><span class="o">).</span><span class="n">within</span><span class="o">(</span><span class="mf">1.</span><span class="n">second</span><span class="o">)</span>
</pre></div>
</div>
</div>
<div class="section" id="request-draining">
<h3>Request Draining<a class="headerlink" href="#request-draining" title="Permalink to this headline">¶</a></h3>
<p>The <cite>Drain</cite> module guarantees that the client delays closure until all
outstanding requests have been completed. It wraps each produced service with
a <a class="reference external" href="https://github.com/twitter/finagle/blob/master/finagle-core/src/main/scala/com/twitter/finagle/service/RefcountedService.scala">RefCountedService</a>.</p>
</div>
<div class="section" id="load-balancing">
<h3>Load Balancing<a class="headerlink" href="#load-balancing" title="Permalink to this headline">¶</a></h3>
<p id="load-balancer">Finagle clients come equipped with a load balancer, a pivotal component in the client stack, whose
responsibility is to dynamically distribute load across a collection of interchangeable endpoints.
This gives Finagle an opportunity to maximize success and optimize request distribution in an attempt
to tighten the client&#8217;s tail latencies. To achieve this in a non-cooperative distributed environment,
the balancer must pass accurate judgments about endpoints based only on its local view. An effective
feedback mechanism in such environments is latency; the balancers load metrics make use of this
either implicitly or explicitly.</p>
<p>Balancer implementations are split into two parts: A <cite>load metric</cite> and a <cite>distributor</cite>. Each node in the
balancer maintains the load metric and a distributor uses the data to select an endpoint.</p>
<p>The default setup for a Finagle client is to use P2C algorithm to distribute load across endpoints, while
picking the least loaded one. See <a class="reference internal" href="#p2c-least-loaded"><span class="std std-ref">P2C + Least Loaded</span></a>
for more details.</p>
<p>There are plenty of useful stats exported from the <cite>Load Balancing</cite> module.
See <a class="reference internal" href="Metrics.html#loadbalancer-stats"><span class="std std-ref">Load Balancing metrics</span></a> for more details.</p>
<p>Use the following code snippet to override the default load balancing strategy for a particular Finagle
client (see <a class="reference external" href="https://github.com/twitter/finagle/blob/master/finagle-core/src/main/scala/com/twitter/finagle/loadbalancer/Balancers.scala">Balancers</a> on how to construct
instances of <code class="docutils literal"><span class="pre">LoadBalancerFactory</span></code>).</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">com.twitter.finagle.Http</span>
<span class="k">import</span> <span class="nn">com.twitter.finagle.loadbalancer.LoadBalancerFactory</span>

<span class="k">val</span> <span class="n">balancer</span><span class="k">:</span> <span class="kt">LoadBalancerFactory</span> <span class="o">=</span> <span class="o">???</span>
<span class="k">val</span> <span class="n">twitter</span> <span class="k">=</span> <span class="nc">Http</span><span class="o">.</span><span class="n">client</span>
  <span class="o">.</span><span class="n">withLoadBalancer</span><span class="o">(</span><span class="n">balancer</span><span class="o">)</span>
  <span class="o">.</span><span class="n">newService</span><span class="o">(</span><span class="s">&quot;twitter.com:8081,twitter.com:8082&quot;</span><span class="o">)</span>
</pre></div>
</div>
<p>In addition to the default configuration (i.e., <code class="docutils literal"><span class="pre">Balancers.p2c</span></code>), the following setups are available.</p>
<div class="section" id="heap-least-loaded">
<h4>Heap + Least Loaded<a class="headerlink" href="#heap-least-loaded" title="Permalink to this headline">¶</a></h4>
<p>The distributor is a heap which is shared across requests. Each node in the heap maintains a count of
outstanding request. The count is incremented when a request is dispatched and decremented when we
receive a response (note the dependence on latency). The heap is min-ordered to allow for
efficient access to the least loaded. The distributor inherits all the nice properties of the heap
(i.e. selecting the top of the heap is constant time and other common operations take <cite>O(log n)</cite>).
This configuration has some limitations. In particular, it’s difficult to use weighted nodes or
swap out a load metric without sacrificing the performance of the heap. What’s more, the heap must be
updated atomically by each request and thus represents a highly contended resource.</p>
<p>Use <code class="docutils literal"><span class="pre">Balancers.heap</span></code> to construct an instance of <code class="docutils literal"><span class="pre">LoadBalancerFactory</span></code>.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">com.twitter.finagle.loadbalancer.</span><span class="o">{</span><span class="nc">Balancers</span><span class="o">,</span> <span class="nc">LoadBalancerFactory</span><span class="o">}</span>

<span class="k">val</span> <span class="n">balancer</span><span class="k">:</span> <span class="kt">LoadBalancerFactory</span> <span class="o">=</span> <span class="nc">Balancers</span><span class="o">.</span><span class="n">heap</span><span class="o">()</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In order to take an advantage of any of the load balancers supported in Finagle, a client
should be configured to talk to a <cite>replica set</cite> (the default finagle stack doesn&#8217;t do <cite>sharding</cite>
and assumes all hosts in the set are interchangeable.)
(see <a class="reference internal" href="Names.html#finagle-names"><span class="std std-ref">Names and Naming in Finagle</span></a> for more details) rather than a single
endpoint.</p>
</div>
</div>
<div class="section" id="power-of-two-choices-p2c-least-loaded">
<span id="p2c-least-loaded"></span><h4>Power of Two Choices (P2C) + Least Loaded<a class="headerlink" href="#power-of-two-choices-p2c-least-loaded" title="Permalink to this headline">¶</a></h4>
<p>The P2C distributor solves many of the limitations that are inherent with the Heap distributor and
is the default balancer for Finagle clients. By employing an elegant (and surprising) mathematical
phenomenon <a class="footnote-reference" href="#p2c" id="id11">[5]</a>, the algorithm randomly picks two nodes from the collection of endpoints and selects
the least loaded of the two. By repeatedly using this strategy, we can expect a manageable upper bound on
the maximum load of any server <a class="footnote-reference" href="#p2c-bounds" id="id12">[6]</a>. The default load metric for the P2C balancer is least
loaded, however, because P2C is fully concurrent <a class="footnote-reference" href="#p2c-jmh" id="id13">[7]</a>, it allows us to efficiently implement
weighted nodes <a class="footnote-reference" href="#weights-api" id="id14">[8]</a> or different load metrics with minimal per-request costs.</p>
<p>Use <code class="docutils literal"><span class="pre">Balancers.p2c</span></code> to construct an instance of <code class="docutils literal"><span class="pre">LoadBalancerFactory</span></code> <a class="footnote-reference" href="#example" id="id15">[3]</a>.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">com.twitter.finagle.loadbalancer.</span><span class="o">{</span><span class="nc">Balancers</span><span class="o">,</span> <span class="nc">LoadBalancerFactory</span><span class="o">}</span>

<span class="k">val</span> <span class="n">balancer</span><span class="k">:</span> <span class="kt">LoadBalancerFactory</span> <span class="o">=</span> <span class="nc">Balancers</span><span class="o">.</span><span class="n">p2c</span><span class="o">(</span><span class="n">maxEffort</span> <span class="k">=</span> <span class="mi">100</span><span class="o">)</span>
</pre></div>
</div>
<p id="max-effort">The <code class="docutils literal"><span class="pre">maxEffort</span></code> param (default value is 5) from the example above is the maximum amount of &#8220;effort&#8221;
we&#8217;re willing to expend on a load balancing decision without rebuilding its internal state. Simply
speaking this is the number of times a load balancer is able to retry because the previously picked
node was <em>marked unavailable</em> (i.e., an underlying circuit breaker is activated). If the <code class="docutils literal"><span class="pre">maxEffort</span></code>
is exhausted and the <em>alive</em> node still hasn&#8217;t been found, the load balancer will send a request to
the last picked one.</p>
</div>
<div class="section" id="power-of-two-choices-p2c-peak-ewma">
<h4>Power of Two Choices (P2C) + Peak EWMA <a class="footnote-reference" href="#experimental" id="id16">[2]</a><a class="headerlink" href="#power-of-two-choices-p2c-peak-ewma" title="Permalink to this headline">¶</a></h4>
<p>Backed by the P2C distributor, Peak EWMA uses a moving average over an endpoint&#8217;s round-trip time (RTT)
that is highly sensitive to peaks. This average is then weighted by the number of outstanding requests,
effectively increasing our resolution per-request. It is designed to react to slow endpoints more quickly than
<cite>least loaded</cite> by penalizing them when they exhibit slow response times. This load metric operates under
the assumption that a loaded endpoint takes time to recover and so it is generally safe for the
advertised load to incorporate an endpoint&#8217;s history. However, this assumption breaks down in the
presence of long polling clients.</p>
<p>Use <code class="docutils literal"><span class="pre">Balancers.p2cPeakEwma</span></code> to construct an instance of <code class="docutils literal"><span class="pre">LoadBalancerFactory</span></code> <a class="footnote-reference" href="#example" id="id17">[3]</a>.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">com.twitter.conversions.time._</span>
<span class="k">import</span> <span class="nn">com.twitter.finagle.loadbalancer.</span><span class="o">{</span><span class="nc">Balancers</span><span class="o">,</span> <span class="nc">LoadBalancerFactory</span><span class="o">}</span>

<span class="k">val</span> <span class="n">balancer</span><span class="k">:</span> <span class="kt">LoadBalancerFactory</span> <span class="o">=</span>
  <span class="nc">Balancers</span><span class="o">.</span><span class="n">p2cPeakEwma</span><span class="o">(</span><span class="n">maxEffort</span> <span class="k">=</span> <span class="mi">100</span><span class="o">,</span> <span class="n">decayTime</span> <span class="k">=</span> <span class="mf">100.</span><span class="n">seconds</span><span class="o">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">p2cPeakEwma</span></code> factory method takes two arguments:</p>
<ol class="arabic simple">
<li><cite>maxEffort</cite> (default: 5) - see <a class="reference internal" href="#max-effort"><span class="std std-ref">P2C&#8217;s max effort</span></a></li>
<li><cite>decayTime</cite> (default: 10 seconds) - the window of latency observations</li>
</ol>
</div>
<div class="section" id="aperture-least-loaded">
<h4>Aperture + Least Loaded <a class="footnote-reference" href="#experimental" id="id18">[2]</a><a class="headerlink" href="#aperture-least-loaded" title="Permalink to this headline">¶</a></h4>
<p>All the previously mentioned configurations operate optimally under high load. That is, without
sufficient concurrent load, the previous distributors can degrade to random selection. The Aperture
distributor aims to remedy this among other things. By employing a simple feedback controller based
on the client&#8217;s load, the distributor balances across a subset of servers to meet a specified
target load band. The principle of hysteresis is applied to the aperture to avoid rapid fluctuations
and dampen the effects of large load spikes.</p>
<p>The benefits of Aperture are promising:</p>
<ol class="arabic simple">
<li>A client uses resources commensurate to offered load. In particular,
it does not have to open sessions with every service in a large cluster.
This is especially important when offered load and cluster capacity
are mismatched.</li>
<li>It balances over fewer, and thus warmer, services. This also means that
clients pay the penalty of session establishment less frequently.</li>
<li>It increases the efficacy of least-loaded balancing which, in order to
work well, requires concurrent load.</li>
</ol>
<p>Use <code class="docutils literal"><span class="pre">Balancers.aperture</span></code> to construct an instance of <code class="docutils literal"><span class="pre">LoadBalancerFactory</span></code> <a class="footnote-reference" href="#example" id="id19">[3]</a>.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">com.twitter.conversions.time._</span>
<span class="k">import</span> <span class="nn">com.twitter.finagle.loadbalancer.</span><span class="o">{</span><span class="nc">Balancers</span><span class="o">,</span> <span class="nc">LoadBalancerFactory</span><span class="o">}</span>

<span class="k">val</span> <span class="n">balancer</span><span class="k">:</span> <span class="kt">LoadBalancerFactory</span> <span class="o">=</span>
  <span class="nc">Balancers</span><span class="o">.</span><span class="n">aperture</span><span class="o">(</span>
    <span class="n">maxEffort</span> <span class="k">=</span> <span class="mi">10</span>
    <span class="n">smoothWin</span> <span class="k">=</span> <span class="mf">32.</span><span class="n">seconds</span><span class="o">,</span>
    <span class="n">lowLoad</span> <span class="k">=</span> <span class="mf">1.0</span><span class="o">,</span>
    <span class="n">highLoad</span> <span class="k">=</span> <span class="mf">2.0</span><span class="o">,</span>
    <span class="n">minAperture</span> <span class="k">=</span> <span class="mi">10</span>
  <span class="o">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">aperture</span></code> factory method takes five arguments:</p>
<ol class="arabic simple">
<li><cite>maxEffort</cite> (default: 5) - see <a class="reference internal" href="#max-effort"><span class="std std-ref">P2C&#8217;s max effort</span></a></li>
<li><cite>smoothWin</cite> (default: 5 seconds) - the window of concurrent load observation</li>
<li>[<cite>lowLoad</cite>, <cite>highLoad</cite>] (default: [0.5, 2]) - the load band used to adjust an aperture size
such that a concurrent load for each endpoint stays within the given interval</li>
<li><cite>minAperture</cite> (default: 1) - the minimum size of the aperture</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The Aperture load balancer should rarely be configured and we are working to provide broadly
applicable defaults.</p>
</div>
</div>
<div class="section" id="role-of-balancers-in-resiliency">
<h4>Role of Balancers in Resiliency<a class="headerlink" href="#role-of-balancers-in-resiliency" title="Permalink to this headline">¶</a></h4>
<p>The balancer&#8217;s primary goal is to attempt to optimize request latency. Coincidentally, to do this
well, it also needs to properly qualify sessions. These two concerns are treated separately in the
client stack. Finagle has dedicated modules which track failures and control the <cite>com.twitter.finagle.Status</cite>
of an endpoint. The balancers selection process takes this status into account. However, without
protocol support the qualification happens in-band with requests (i.e. it requires failed requests).
We are exploring better (explicit) session qualification with protocol support (e.g. Mux).</p>
<p>Additionally, clients must be resilient to instabilities in the service discovery system.
Historically, Finagle has employed solutions like <cite>com.twitter.finagle.addr.StabilizingAddr</cite> and
<cite>com.twitter.finagle.serverset2.Stabilizer</cite> to validate changes to the balancers endpoint collection.
Since we have information about the availability of an endpoint in the balancer, it may represent
a viable intersection to validate such changes. Balancers have a &#8220;probation&#8221; capability built-in
behind a client parameter <a class="footnote-reference" href="#probation" id="id20">[9]</a>.</p>
</div>
<div class="section" id="behavior-when-no-nodes-are-available">
<h4>Behavior when no nodes are available<a class="headerlink" href="#behavior-when-no-nodes-are-available" title="Permalink to this headline">¶</a></h4>
<p>When there are no nodes in the <cite>com.twitter.finagle.Status.Open</cite> state, the balancers
must make a decision. Finagle&#8217;s default behavior makes an optimistic decision
that its view of the nodes may be out-of-date and picks a node it hopes has become available.
This can be customized to fail the request immediately through
<code class="docutils literal"><span class="pre">LoadBalancerFactory.WhenNoNodesOpenParam</span></code> which will cause clients to see
a non-retryable <code class="docutils literal"><span class="pre">c.t.f.loadbalancer.NoNodesOpenException</span></code>:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">com.twitter.finagle.loadbalancer.LoadBalancerFactory.WhenNoNodesOpenParam</span>
<span class="k">import</span> <span class="nn">com.twitter.finagle.loadbalancer.WhenNoNodesOpen</span>
<span class="k">import</span> <span class="nn">com.twitter.finagle.Http</span>

<span class="nc">Http</span><span class="o">.</span><span class="n">client</span>
  <span class="o">.</span><span class="n">configured</span><span class="o">(</span><span class="nc">WhenNoNodesOpenParam</span><span class="o">(</span><span class="nc">WhenNoNodesOpen</span><span class="o">.</span><span class="nc">FailFast</span><span class="o">))</span>
</pre></div>
</div>
<p><a class="reference internal" href="Metrics.html#loadbalancer-stats"><span class="std std-ref">Related stats</span></a></p>
</div>
</div>
<div class="section" id="circuit-breaking">
<span id="client-circuit-breaking"></span><h3>Circuit Breaking<a class="headerlink" href="#circuit-breaking" title="Permalink to this headline">¶</a></h3>
<p>The following modules aim to preemptively disable sessions that will likely fail requests.
From the perspective of the load balancer, they act as circuit breakers which, when
triggered, temporarily suspend the use of a particular endpoint.</p>
<p>There are at least two modules in the client stacks that might be viewed as circuit breakers:</p>
<ol class="arabic simple">
<li><cite>Fail Fast</cite> - a session-driven circuit breaker</li>
<li><cite>Failure Accrual</cite> - a <a class="reference external" href="http://martinfowler.com/bliki/CircuitBreaker.html">request-driven circuit breaker</a></li>
</ol>
<p>In addition to <cite>Fail Fast</cite> and <cite>Failure Accrual</cite>, some of the protocols (i.e., <cite>Mux</cite>) in
Finagle support <cite>Ping-based Failure Detectors</cite> <a class="footnote-reference" href="#failure-detectors" id="id21">[10]</a>
(i.e., <a class="reference external" href="https://github.com/twitter/finagle/blob/master/finagle-core/src/main/scala/com/twitter/finagle/liveness/ThresholdFailureDetector.scala">ThresholdFailureDetector</a>).</p>
<div class="section" id="fail-fast">
<span id="client-fail-fast"></span><h4>Fail Fast<a class="headerlink" href="#fail-fast" title="Permalink to this headline">¶</a></h4>
<p>The <a class="reference external" href="https://github.com/twitter/finagle/blob/master/finagle-core/src/main/scala/com/twitter/finagle/service/FailFastFactory.scala">FailFast</a> module
attempts to reduce the number of requests dispatched to endpoints that are likely
to fail. It works by marking downed hosts when a connection fails, and launching a
background process that repeatedly attempts to reconnect with a given backoff schedule.
During the time that a host is marked down, the factory is marked unavailable (and thus
the load balancer above it will avoid its use). The factory becomes available
again on success or when the back-off schedule runs out.</p>
<p>See the FAQ to <a class="reference internal" href="FAQ.html#faq-failedfastexception"><span class="std std-ref">better understand</span></a> why clients
might be seeing <code class="docutils literal"><span class="pre">com.twitter.finagle.FailedFastException</span></code>&#8216;s.</p>
<p id="disabling-fail-fast">The <cite>Fail Fast</cite> module is enabled by default for all of the Finagle clients except for
<code class="docutils literal"><span class="pre">Memcached.client</span></code> one. The following example demonstrates how to explicitly disable it for a
particular client.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">com.twitter.finagle.Http</span>

<span class="k">val</span> <span class="n">twitter</span> <span class="k">=</span> <span class="nc">Http</span><span class="o">.</span><span class="n">client</span>
  <span class="o">.</span><span class="n">withSessionQualifier</span><span class="o">.</span><span class="n">noFailFast</span>
  <span class="o">.</span><span class="n">newService</span><span class="o">(</span><span class="s">&quot;twitter.com&quot;</span><span class="o">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It&#8217;s important to disable <cite>Fail Fast</cite> when only have one host in the replica set because
Finagle doesn&#8217;t have any other path to choose.</p>
</div>
<p><a class="reference internal" href="Metrics.html#fail-fast-stats"><span class="std std-ref">Related stats</span></a></p>
</div>
<div class="section" id="failure-accrual">
<span id="client-failure-accrual"></span><h4>Failure Accrual<a class="headerlink" href="#failure-accrual" title="Permalink to this headline">¶</a></h4>
<p>The <cite>Failure Accrual</cite> module marks itself as unavailable based on the number of observed
failures. The module remains unavailable for a predefined duration. Recall
that the availability is propagated through the stack. Thus the load balancer
will avoid using an endpoint where the failure accrual module is unavailable.
The module is implemented by <a class="reference external" href="https://github.com/twitter/finagle/blob/master/finagle-core/src/main/scala/com/twitter/finagle/liveness/FailureAccrualFactory.scala">FailureAccrualFactory</a>.</p>
<p>See <a class="reference internal" href="Metrics.html#failure-accrual-stats"><span class="std std-ref">Failure Accrual Stats</span></a> for stats exported from the
<code class="docutils literal"><span class="pre">Failure</span> <span class="pre">Accrual</span></code> module.</p>
<p>The <code class="docutils literal"><span class="pre">FailureAccrualFactory</span></code> is configurable in terms of used policy to determine whether to mark
an endpoint dead upon a request failure. At this point, there are two setups available out of
the box.</p>
<ol class="arabic simple">
<li>A policy based on the requests success rate meaning (i.e, an endpoint marked dead if its success rate
goes bellow the given threshold)</li>
<li>A policy based on the number of consecutive failures occurred in the endpoint (i.e., an endpoint marked
dead if there are at least <code class="docutils literal"><span class="pre">N</span></code> consecutive failures occurred in this endpoint)</li>
</ol>
<p>The default setup for the <cite>Failure Accrual</cite> module is to use a policy based on the
number of consecutive failures (default is 5) accompanied by equal jittered backoff <a class="footnote-reference" href="#backoff" id="id22">[1]</a> producing
durations for which an endpoint is marked dead.</p>
<p>Use <code class="docutils literal"><span class="pre">FailureAccrualFactory.Param</span></code> <a class="footnote-reference" href="#experimental" id="id23">[2]</a> to configure Failure Accrual` based on requests
success rate <a class="footnote-reference" href="#example" id="id24">[3]</a>.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">com.twitter.conversions.time._</span>
<span class="k">import</span> <span class="nn">com.twitter.finagle.Http</span>
<span class="k">import</span> <span class="nn">com.twitter.finagle.liveness.</span><span class="o">{</span><span class="nc">FailureAccrualFactory</span><span class="o">,</span> <span class="nc">FailureAccrualPolicy</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">com.twitter.finagle.service.Backoff</span>

<span class="k">val</span> <span class="n">twitter</span> <span class="k">=</span> <span class="nc">Http</span><span class="o">.</span><span class="n">client</span>
  <span class="o">.</span><span class="n">configured</span><span class="o">(</span><span class="nc">FailureAccrualFactory</span><span class="o">.</span><span class="nc">Param</span><span class="o">(()</span> <span class="k">=&gt;</span> <span class="nc">FailureAccrualPolicy</span><span class="o">.</span><span class="n">successRate</span><span class="o">(</span>
    <span class="n">requiredSuccessRate</span> <span class="k">=</span> <span class="mf">0.95</span><span class="o">,</span>
    <span class="n">window</span> <span class="k">=</span> <span class="mi">100</span><span class="o">,</span>
    <span class="n">markDeadFor</span> <span class="k">=</span> <span class="nc">Backoff</span><span class="o">.</span><span class="n">const</span><span class="o">(</span><span class="mf">10.</span><span class="n">seconds</span><span class="o">)</span>
  <span class="o">)))</span>
  <span class="o">.</span><span class="n">newService</span><span class="o">(</span><span class="s">&quot;twitter.com&quot;</span><span class="o">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">successRate</span></code> factory method takes three arguments:</p>
<ol class="arabic simple">
<li><cite>requiredSuccessRate</cite> - the minimally required success rate bellow which an endpoint marked dead</li>
<li><cite>window</cite> - the size of the window to tack success rate on</li>
<li><cite>markDeadFor</cite> - the backoff policy (an instance of <code class="docutils literal"><span class="pre">Stream[Duration]</span></code>) used to mark an endpoint
dead for</li>
</ol>
<p>To configure <cite>Failure Accrual</cite> based on a number of consecutive failures <a class="footnote-reference" href="#experimental" id="id25">[2]</a>, use the
following snippet <a class="footnote-reference" href="#example" id="id26">[3]</a>.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">com.twitter.conversions.time._</span>
<span class="k">import</span> <span class="nn">com.twitter.finagle.Http</span>
<span class="k">import</span> <span class="nn">com.twitter.finagle.liveness.</span><span class="o">{</span><span class="nc">FailureAccrualFactory</span><span class="o">,</span> <span class="nc">FailureAccrualPolicy</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">com.twitter.finagle.service.Backoff</span>

<span class="k">val</span> <span class="n">twitter</span> <span class="k">=</span> <span class="nc">Http</span><span class="o">.</span><span class="n">client</span>
  <span class="o">.</span><span class="n">configured</span><span class="o">(</span><span class="nc">FailureAccrual</span><span class="o">.</span><span class="nc">Param</span><span class="o">(()</span> <span class="k">=&gt;</span> <span class="nc">FailureAccrualPolicy</span><span class="o">.</span><span class="n">consecutiveFailures</span><span class="o">(</span>
    <span class="n">numFailures</span> <span class="k">=</span> <span class="mi">10</span><span class="o">,</span>
    <span class="n">markDeadFor</span> <span class="k">=</span> <span class="nc">Backoff</span><span class="o">.</span><span class="n">const</span><span class="o">(</span><span class="mf">10.</span><span class="n">seconds</span><span class="o">)</span>
  <span class="o">)))</span>
  <span class="o">.</span><span class="n">newService</span><span class="o">(</span><span class="s">&quot;twitter.com&quot;</span><span class="o">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">consecutiveFailures</span></code> method takes two arguments:</p>
<ol class="arabic simple">
<li><cite>consecutiveFailures</cite> - the number of failures after which an endpoint is marked dead</li>
<li><cite>markDeadFor</cite> - the backoff policy (an instance of <code class="docutils literal"><span class="pre">Stream[Duration]</span></code>) used to mark an endpoint
dead for</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It&#8217;s highly recommended to use <a class="reference external" href="https://github.com/twitter/finagle/blob/master/finagle-core/src/main/scala/com/twitter/finagle/service/Backoff.scala">Backoff</a>
API for constructing instances of <code class="docutils literal"><span class="pre">Stream[Duration]</span></code> instead of using the error-prone Stream API directly.</p>
</div>
<p>Finally, it&#8217;s possible to completely disable the <cite>Failure Accrual</cite> module for a given
client.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">com.twitter.finagle.Http</span>

<span class="k">val</span> <span class="n">twitter</span> <span class="k">=</span> <span class="nc">Http</span><span class="o">.</span><span class="n">client</span>
  <span class="o">.</span><span class="n">withSessionQualifier</span><span class="o">.</span><span class="n">noFailureAccrual</span>
  <span class="o">.</span><span class="n">newService</span><span class="o">(</span><span class="s">&quot;twitter.com&quot;</span><span class="o">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="pooling">
<h3>Pooling<a class="headerlink" href="#pooling" title="Permalink to this headline">¶</a></h3>
<p>Many protocols benefit from having persistent connections that are reused across requests.
Pooling is designed to balance connection churn and service acquisition latency at the cost of holding
resources open.</p>
<p>Depending on the configuration, a Finagle client&#8217;s stack might contain up to _three_ connection pools
stacked on each other: watermark, caching and buffering pools.</p>
<p>The only Finagle protocol that doesn&#8217;t require any connection pooling (a multiplexing protocol) is
<cite>Mux</cite> so it uses <a class="reference external" href="https://github.com/twitter/finagle/blob/master/finagle-core/src/main/scala/com/twitter/finagle/pool/SingletonPool.scala">SingletonPool</a> that maintains
a single connection per endpoint. For every other Finagle-supported protocol (i.e., HTTP/1.1, Thrift),
there a connection pooling setup built with watermark and caching pools.</p>
<p>The default client stack layers caching and watermark pools which amounts to maintaining the low
watermark (i.e., <code class="docutils literal"><span class="pre">0</span></code>, as long as request concurrency exists), queuing requests above the unbounded high
watermark (i.e., <code class="docutils literal"><span class="pre">Int.MaxValue</span></code>), and applying an unbounded TTL (i.e., <code class="docutils literal"><span class="pre">Duration.Top</span></code>) for services
that are between [low, high].</p>
<p>The override the default settings for connection pooling in a Finagle client, use the following
example <a class="footnote-reference" href="#example" id="id27">[3]</a>.</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">com.twitter.conversions.time._</span>
<span class="k">import</span> <span class="nn">com.twitter.finagle.Http</span>

<span class="k">val</span> <span class="n">twitter</span> <span class="k">=</span> <span class="nc">Http</span><span class="o">.</span><span class="n">client</span>
  <span class="o">.</span><span class="n">withSessionPool</span><span class="o">.</span><span class="n">minSize</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>
  <span class="o">.</span><span class="n">withSessionPool</span><span class="o">.</span><span class="n">maxSize</span><span class="o">(</span><span class="mi">20</span><span class="o">)</span>
  <span class="o">.</span><span class="n">withSessionPool</span><span class="o">.</span><span class="n">maxWaiters</span><span class="o">(</span><span class="mi">100</span><span class="o">)</span>
  <span class="o">.</span><span class="n">newService</span><span class="o">(</span><span class="s">&quot;twitter.com&quot;</span><span class="o">)</span>
</pre></div>
</div>
<p>Thus all the three pools are configured with a single param that takes the following arguments:</p>
<ol class="arabic simple">
<li><cite>minSize</cite> and <cite>maxSize</cite> - low and high watermarks for the watermark pool (note that a Finagle
client will not maintain more connections than <cite>maxSize</cite>)</li>
<li><cite>maxWaiters</cite> - the maximum number of connection requests that are queued when the connection
concurrency exceeds the high watermark</li>
</ol>
<p><a class="reference internal" href="Metrics.html#pool-stats"><span class="std std-ref">Related stats</span></a></p>
<div class="section" id="buffering-pool">
<h4>Buffering Pool<a class="headerlink" href="#buffering-pool" title="Permalink to this headline">¶</a></h4>
<p>The simplest connection pool implementation available in Finagle is
<a class="reference external" href="https://github.com/twitter/finagle/blob/master/finagle-core/src/main/scala/com/twitter/finagle/pool/BufferingPool.scala">BufferingPool</a> that just buffers up to
<code class="docutils literal"><span class="pre">bufferSize</span></code> connections and produces/closes new ones above it. This pool is disabled by
default.</p>
</div>
<div class="section" id="watermark-pool">
<span id="id28"></span><h4>Watermark Pool<a class="headerlink" href="#watermark-pool" title="Permalink to this headline">¶</a></h4>
<p>Finagle provides a generic pool that maintains a collection of service instances. Each endpoint
the client connects to has an independent pool with high and low watermarks.
The <a class="reference external" href="https://github.com/twitter/finagle/blob/master/finagle-core/src/main/scala/com/twitter/finagle/pool/WatermarkPool.scala">WatermarkPool</a> keeps persistent services
up to the lower bound. It will keep making new services up to upper bound if you checkout more
than lower bound services, but when you release those services above the lower bound, it
immediately tries to close them. This, however, creates a lot of connection churn if your
application consistently requires more than lower bound connections.</p>
</div>
<div class="section" id="caching-pool">
<h4>Caching Pool<a class="headerlink" href="#caching-pool" title="Permalink to this headline">¶</a></h4>
<p id="id29">To reduce connection churn, there is a separate facility for caching, with some TTL,
services above the lower bound. The <a class="reference external" href="https://github.com/twitter/finagle/blob/master/finagle-core/src/main/scala/com/twitter/finagle/pool/CachingPool.scala">CachingPool</a>
caches <em>regardless</em> of whether there are more than lower-bound open services;
it&#8217;s always caching up to (upper-bound - lower-bound) services. The cache reaches
its peak value when you reach your peak concurrency (i.e. &#8220;load&#8221;),
and then slowly decays, based on the TTL.</p>
<p><a class="reference internal" href="Metrics.html#pool-stats"><span class="std std-ref">Related stats</span></a></p>
</div>
</div>
</div>
<div class="section" id="admission-control">
<h2>Admission Control<a class="headerlink" href="#admission-control" title="Permalink to this headline">¶</a></h2>
<p>Clients are configured with the <a class="reference external" href="https://github.com/twitter/finagle/blob/master/finagle-core/src/main/scala/com/twitter/finagle/filter/NackAdmissionFilter.scala">NackAdmissionFilter</a>
which will probabilistically drop some requests to unhealthy clusters. This aims
to decrease the request volume to those clusters with little to no effect on a
client&#8217;s already unhealthy success rate. The filter works by keeping a moving
average of the fraction of requests that are <a class="reference internal" href="Glossary.html#glossary-nack"><span class="std std-ref">nacked</span></a>. When
this fraction hits a given threshold, the filter will probabilistically drop
requests in proportion to that fraction.
The filter can be configured with the following parameters:</p>
<ol class="arabic simple">
<li><code class="docutils literal"><span class="pre">window</span></code> The duration over which the average is calculated. Default is 2
minutes.</li>
<li><code class="docutils literal"><span class="pre">nackRateThreshold</span></code> The rate of rejected requests at which the filter kicks
in. Default is 0.5.</li>
</ol>
<p><a class="reference internal" href="Metrics.html#admission-control-stats"><span class="std std-ref">Related stats</span></a></p>
</div>
<div class="section" id="response-classification">
<span id="id30"></span><h2>Response Classification<a class="headerlink" href="#response-classification" title="Permalink to this headline">¶</a></h2>
<p>To give Finagle visibility into application level success and failure
developers can provide classification of responses on clients and servers by using
<a class="reference external" href="https://github.com/twitter/finagle/blob/master/finagle-core/src/main/scala/com/twitter/finagle/service/package.scala">response classifiers</a>.
This gives Finagle the proper domain knowledge and improves the efficacy of
<a class="reference internal" href="#client-failure-accrual"><span class="std std-ref">failure accrual</span></a> and more accurate
<a class="reference internal" href="Metrics.html#metrics-stats-filter"><span class="std std-ref">success rate stats</span></a>.</p>
<p>For HTTP clients and servers, using <code class="docutils literal"><span class="pre">HttpResponseClassifier.ServerErrorsAsFailures</span></code> often works
great as it classifies any HTTP 5xx response code as a failure. For Thrift/ThriftMux
clients you may want to use <code class="docutils literal"><span class="pre">ThriftResponseClassifier.ThriftExceptionsAsFailures</span></code>
which classifies any deserialized Thrift Exception as a failure. For a large set of
use cases these should suffice. Classifiers get wired up to your client and server in a
straightforward manner, for example, in a ThriftMux client:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">com.twitter.finagle.ThriftMux</span>
<span class="k">import</span> <span class="nn">com.twitter.finagle.thrift.service.ThriftResponseClassifier</span>

<span class="nc">ThriftMux</span><span class="o">.</span><span class="n">client</span>
  <span class="o">...</span>
  <span class="o">.</span><span class="n">withResponseClassifier</span><span class="o">(</span><span class="nc">ThriftResponseClassifier</span><span class="o">.</span><span class="nc">ThriftExceptionsAsFailures</span><span class="o">)</span>
</pre></div>
</div>
<p>In an HTTP server:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">com.twitter.finagle.Http</span>
<span class="k">import</span> <span class="nn">com.twitter.finagle.http.service.HttpResponseClassifier</span>

<span class="nc">Http</span><span class="o">.</span><span class="n">server</span>
  <span class="o">...</span>
  <span class="o">.</span><span class="n">withResponseClassifier</span><span class="o">(</span><span class="nc">HttpResponseClassifier</span><span class="o">.</span><span class="nc">ServerErrorsAsFailures</span><span class="o">)</span>
</pre></div>
</div>
<p>If a classifier is not specified on a client or server or if a user&#8217;s classifier isn&#8217;t
defined for a given request/response pair then <code class="docutils literal"><span class="pre">ResponseClassifier.Default</span></code>
is used. This gives us the simple classification rules of responses that are
<code class="docutils literal"><span class="pre">Returns</span></code> are successful and <code class="docutils literal"><span class="pre">Throws</span></code> are failures.</p>
<div class="section" id="custom-classifiers">
<h3>Custom Classifiers<a class="headerlink" href="#custom-classifiers" title="Permalink to this headline">¶</a></h3>
<p>Writing a custom classifier requires understanding of the few classes used. A
<code class="docutils literal"><span class="pre">ResponseClassifier</span></code> is a <code class="docutils literal"><span class="pre">PartialFunction</span></code> from <code class="docutils literal"><span class="pre">ReqRep</span></code> to
<code class="docutils literal"><span class="pre">ResponseClass</span></code>.</p>
<p>Let&#8217;s work our way backwards through those, beginning with <code class="docutils literal"><span class="pre">ResponseClass</span></code>.
This can be either <code class="docutils literal"><span class="pre">Successful</span></code> or <code class="docutils literal"><span class="pre">Failed</span></code> and those values are
self-explanatory. There are three constants which will cover the vast majority
of usage: <code class="docutils literal"><span class="pre">Success</span></code>, <code class="docutils literal"><span class="pre">NonRetryableFailure</span></code> and <code class="docutils literal"><span class="pre">RetryableFailure</span></code>. While
as of today there is no distinction made between retryable and non-retryable
failures, this lays the groundwork for use in the future.</p>
<p>A <code class="docutils literal"><span class="pre">ReqRep</span></code> is a request/response struct with a request of type <code class="docutils literal"><span class="pre">Any</span></code> and a
response of type <code class="docutils literal"><span class="pre">Try[Any]</span></code>. While all of this functionality is called
response classification, you’ll note that classifiers make judgements on both a
request and response.</p>
<p>Creating a custom <code class="docutils literal"><span class="pre">ResponseClassifier</span></code> is fairly straightforward for HTTP
as the <code class="docutils literal"><span class="pre">ReqRep</span></code> is an <code class="docutils literal"><span class="pre">http.Request</span></code> and <code class="docutils literal"><span class="pre">Try[http.Response]</span></code> pair.
Here is an example that counts HTTP 503s as failures:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">com.twitter.finagle.http</span>
<span class="k">import</span> <span class="nn">com.twitter.finagle.service.</span><span class="o">{</span><span class="nc">ReqRep</span><span class="o">,</span> <span class="nc">ResponseClass</span><span class="o">,</span> <span class="nc">ResponseClassifier</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">com.twitter.util.Return</span>

<span class="k">val</span> <span class="n">classifier</span><span class="k">:</span> <span class="kt">ResponseClassifier</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">ReqRep</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="nc">Return</span><span class="o">(</span><span class="n">r</span><span class="k">:</span> <span class="kt">http.Response</span><span class="o">))</span> <span class="k">if</span> <span class="n">r</span><span class="o">.</span><span class="n">statusCode</span> <span class="o">==</span> <span class="mi">503</span> <span class="k">=&gt;</span>
    <span class="nc">ResponseClass</span><span class="o">.</span><span class="nc">NonRetryableFailure</span>
<span class="o">}</span>
</pre></div>
</div>
<p>Note that this <code class="docutils literal"><span class="pre">PartialFunction</span></code> isn&#8217;t total which is ok due to Finagle
always using user defined classifiers in combination with
<code class="docutils literal"><span class="pre">ResponseClassifier.Default</span></code> which will cover all cases.</p>
</div>
<div class="section" id="thrift-and-thriftmux-classifiers">
<h3>Thrift and ThriftMux Classifiers<a class="headerlink" href="#thrift-and-thriftmux-classifiers" title="Permalink to this headline">¶</a></h3>
<p>Thrift and ThriftMux classifiers require a bit more care as the request and
response types are not as obvious. This is because there is only a single
<code class="docutils literal"><span class="pre">Service</span></code> from <code class="docutils literal"><span class="pre">Array[Byte]</span></code> to <code class="docutils literal"><span class="pre">Array[Byte]</span></code> for all the methods of an
IDL&#8217;s service. To make this workable, there is support in Scrooge and
<code class="docutils literal"><span class="pre">Thrift/ThriftMux.newService</span></code> and <code class="docutils literal"><span class="pre">Thrift/ThriftMux.newClient</span></code> code to
deserialize the responses into the expected application types so that
classifiers can be written in terms of the Scrooge generated request type,
<code class="docutils literal"><span class="pre">$Service.$Method.Args</span></code>, and the method&#8217;s response type. Given an IDL:</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>exception NotFoundException { 1: string reason }

service SocialGraph {
  i32 follow(1: i64 follower, 2: i64 followee) throws (1: NotFoundException ex)
}
</pre></div>
</div>
<p>One possible classifier would be:</p>
<div class="highlight-scala"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">com.twitter.finagle.service.</span><span class="o">{</span><span class="nc">ReqRep</span><span class="o">,</span> <span class="nc">ResponseClass</span><span class="o">,</span> <span class="nc">ResponseClassifier</span><span class="o">}</span>

<span class="k">val</span> <span class="n">classifier</span><span class="k">:</span> <span class="kt">ResponseClassifier</span> <span class="o">=</span> <span class="o">{</span>
  <span class="c1">// #1</span>
  <span class="k">case</span> <span class="nc">ReqRep</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="nc">Throw</span><span class="o">(</span><span class="k">_:</span> <span class="kt">NotFoundException</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="nc">ResponseClass</span><span class="o">.</span><span class="nc">NonRetryableFailure</span>

  <span class="c1">// #2</span>
  <span class="k">case</span> <span class="nc">ReqRep</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="nc">Return</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">))</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">=&gt;</span>
    <span class="nc">ResponseClass</span><span class="o">.</span><span class="nc">NonRetryableFailure</span>

  <span class="c1">// #3</span>
  <span class="k">case</span> <span class="nc">ReqRep</span><span class="o">(</span><span class="nc">SocialGraph</span><span class="o">.</span><span class="nc">Follow</span><span class="o">.</span><span class="nc">Args</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">),</span> <span class="k">_</span><span class="o">)</span> <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">=&gt;</span>
    <span class="nc">ResponseClass</span><span class="o">.</span><span class="nc">NonRetryableFailure</span>
<span class="o">}</span>
</pre></div>
</div>
<p>If you examine that classifier you&#8217;ll note a few things. First (#1), the
deserialized <code class="docutils literal"><span class="pre">NotFoundException</span></code> can be treated as a failure. Next (#2), a
&#8220;successful&#8221; response can be examined to enable services using status codes to
classify errors. Lastly (#3), the request can be introspected to make the
decision.</p>
</div>
<div class="section" id="other-details">
<h3>Other Details<a class="headerlink" href="#other-details" title="Permalink to this headline">¶</a></h3>
<p>If you have a response classifier that categorizes <code class="docutils literal"><span class="pre">Returns</span></code> as
failures, note that they will be counted in the <code class="docutils literal"><span class="pre">StatsFilter</span></code>
as a <code class="docutils literal"><span class="pre">com.twitter.finagle.service.ResponseClassificationSyntheticException</span></code> in the
<code class="docutils literal"><span class="pre">StatsReceiver</span></code> to indicate when this happens. See the
<a class="reference external" href="https://twitter.github.io/finagle/guide/FAQ.html#what-is-a-com-twitter-finagle-service-responseclassificationsyntheticexception">FAQ</a>
for more details.</p>
</div>
</div>
<div class="section" id="methodbuilder">
<h2>MethodBuilder<a class="headerlink" href="#methodbuilder" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Currently there is <code class="docutils literal"><span class="pre">MethodBuilder</span></code> support for HTTP and ThriftMux.
We are waiting on user interest before expanding to more protocols.</p>
</div>
<p><code class="docutils literal"><span class="pre">MethodBuilder</span></code> is a collection of APIs for client configuration at a higher
level than the  <a class="reference internal" href="Configuration.html#finagle6apis"><span class="std std-ref">Finagle 6 APIs</span></a> while improving upon the deprecated
<code class="docutils literal"><span class="pre">ClientBuilder</span></code>. <code class="docutils literal"><span class="pre">MethodBuilder</span></code> provides:</p>
<ul class="simple">
<li><a class="reference internal" href="MethodBuilder.html#mb-logical-req"><span class="std std-ref">Logical</span></a> success rate metrics.</li>
<li>Retries based on application-level requests and responses (e.g. an HTTP
503 response code or a Thrift exception).</li>
<li>Configuration of per-attempt and total timeouts.</li>
</ul>
<p><a class="reference internal" href="MethodBuilder.html"><span class="doc">Learn more</span></a> about <code class="docutils literal"><span class="pre">MethodBuilder</span></code>.</p>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="backoff" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id4">2</a>, <a class="fn-backref" href="#id5">3</a>, <a class="fn-backref" href="#id22">4</a>)</em> Most of the backoff strategies implemented in Finagle are inspired by Mark
Brooker&#8217;s <a class="reference external" href="http://www.awsarchitectureblog.com/2015/03/backoff.html">blog post</a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="experimental" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id16">1</a>, <a class="fn-backref" href="#id18">2</a>, <a class="fn-backref" href="#id23">3</a>, <a class="fn-backref" href="#id25">4</a>)</em> This configuration was developed to target specific problems we encounter
at Twitter and should be considered experimental. Note that its API may change as we continue
to understand its place in the stack.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="example" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td><em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id6">2</a>, <a class="fn-backref" href="#id7">3</a>, <a class="fn-backref" href="#id8">4</a>, <a class="fn-backref" href="#id9">5</a>, <a class="fn-backref" href="#id15">6</a>, <a class="fn-backref" href="#id17">7</a>, <a class="fn-backref" href="#id19">8</a>, <a class="fn-backref" href="#id24">9</a>, <a class="fn-backref" href="#id26">10</a>, <a class="fn-backref" href="#id27">11</a>)</em> Configuration parameters/values provided in this example are only to demonstrate
the API usage, not the real world values. We do not recommend blindly applying those values
to production systems.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="raise" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[4]</a></td><td>The <cite>Future#within</cite> variant creates a new future that invokes raise on the future
when the timeout occurs. The affects of which are dependent on the producer of the future.
In most cases, Finagle will attempt to cancel the request if it hasn&#8217;t already been dispatched.
If it has been dispatched, the behavior is dependent on the protocol (without protocol
support Finagle needs to tear down the session to signal cancellation).</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="p2c" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[5]</a></td><td>Michael Mitzenmacher. 2001. The Power of Two Choices in Randomized Load Balancing.
IEEE Trans. Parallel Distrib. Syst. 12, 10 (October 2001), 1094-1104.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="p2c-bounds" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[6]</a></td><td>The maximum load variance between any two servers is bound by <cite>ln(ln(n))</cite>
where n is the number of servers in the cluster.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="p2c-jmh" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[7]</a></td><td>Our micro benchmark exposes the stark differences:</td></tr>
</tbody>
</table>
<div class="highlight-text"><div class="highlight"><pre><span></span>HeapBalancer.getAndPut           1000  avgt  10 8686.479 ± 261.360 ns/op
P2CBalancer.leastLoadedGetAndPut 1000  avgt  10 1692.388 ± 103.164 ns/op
</pre></div>
</div>
<table class="docutils footnote" frame="void" id="weights-api" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14">[8]</a></td><td>Weights are built into all the balancers except for the <code class="docutils literal"><span class="pre">HeapBalancer</span></code>.
The API exposed for this is in <code class="docutils literal"><span class="pre">com.twitter.finagle.WeightedSocketAddress</span></code>. The name
resolver that translates logical destinations to <code class="docutils literal"><span class="pre">com.twitter.finagle.Addr</span></code> can wrap
concrete address with a <cite>Double</cite> which influences the balancer&#8217;s distributor during the
selection process.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="probation" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id20">[9]</a></td><td>See <code class="docutils literal"><span class="pre">com.twitter.finagle.loadbalancer.LoadBalancerFactory#EnableProbation</span></code>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="failure-detectors" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id21">[10]</a></td><td>See <cite>Failure Detectors</cite> section from
Alvaro Videla&#8217;s <a class="reference external" href="http://videlalvaro.github.io/2015/12/learning-about-distributed-systems.html">blog post</a>.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><p class="logo"><a href="index.html">
  <img class="logo" src="_static/logo_small.png" alt="Logo"/>
</a></p><a href="index.html"><h3>Finagle</h3></a>
<p>
  Finagle is a network stack for distributed systems.
</p>

<h3>Useful Links</h3>
<ul>
  <li><a href="http://github.com/twitter/finagle">Finagle @ GitHub</a></li>
  <li><a href="http://github.com/twitter/finagle/issues">Issue Tracker</a></li>
</ul>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Clients</a><ul>
<li><a class="reference internal" href="#transport">Transport</a><ul>
<li><a class="reference internal" href="#http-proxy">HTTP Proxy</a></li>
<li><a class="reference internal" href="#socks5-proxy">SOCKS5 Proxy</a></li>
</ul>
</li>
<li><a class="reference internal" href="#client-modules">Client Modules</a><ul>
<li><a class="reference internal" href="#module-composition">Module Composition</a></li>
<li><a class="reference internal" href="#observability">Observability</a></li>
<li><a class="reference internal" href="#retries">Retries</a></li>
<li><a class="reference internal" href="#timeouts-expiration">Timeouts &amp; Expiration</a></li>
<li><a class="reference internal" href="#request-draining">Request Draining</a></li>
<li><a class="reference internal" href="#load-balancing">Load Balancing</a><ul>
<li><a class="reference internal" href="#heap-least-loaded">Heap + Least Loaded</a></li>
<li><a class="reference internal" href="#power-of-two-choices-p2c-least-loaded">Power of Two Choices (P2C) + Least Loaded</a></li>
<li><a class="reference internal" href="#power-of-two-choices-p2c-peak-ewma">Power of Two Choices (P2C) + Peak EWMA </a></li>
<li><a class="reference internal" href="#aperture-least-loaded">Aperture + Least Loaded </a></li>
<li><a class="reference internal" href="#role-of-balancers-in-resiliency">Role of Balancers in Resiliency</a></li>
<li><a class="reference internal" href="#behavior-when-no-nodes-are-available">Behavior when no nodes are available</a></li>
</ul>
</li>
<li><a class="reference internal" href="#circuit-breaking">Circuit Breaking</a><ul>
<li><a class="reference internal" href="#fail-fast">Fail Fast</a></li>
<li><a class="reference internal" href="#failure-accrual">Failure Accrual</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pooling">Pooling</a><ul>
<li><a class="reference internal" href="#buffering-pool">Buffering Pool</a></li>
<li><a class="reference internal" href="#watermark-pool">Watermark Pool</a></li>
<li><a class="reference internal" href="#caching-pool">Caching Pool</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#admission-control">Admission Control</a></li>
<li><a class="reference internal" href="#response-classification">Response Classification</a><ul>
<li><a class="reference internal" href="#custom-classifiers">Custom Classifiers</a></li>
<li><a class="reference internal" href="#thrift-and-thriftmux-classifiers">Thrift and ThriftMux Classifiers</a></li>
<li><a class="reference internal" href="#other-details">Other Details</a></li>
</ul>
</li>
<li><a class="reference internal" href="#methodbuilder">MethodBuilder</a></li>
</ul>
</li>
</ul>
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="Servers.html" title="previous chapter">Servers</a></li>
      <li>Next: <a href="Contexts.html" title="next chapter">Contexts</a></li>
  </ul></li>
</ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Search the contents of this site.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
  <div class="footer">&copy; Copyright 2018 Twitter, Inc.</div>
  
  </body>
</html>